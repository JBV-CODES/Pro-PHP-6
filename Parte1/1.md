# 1. Intro. a la POO 
####[CONTENIDOS DEL LIBRO](https://github.com/JBV-CODES/Pro-PHP-6)
- [¿Qué es POO?](https://github.com/JBV-CODES/Pro-PHP-6/blob/master/Parte1/1.md#qué-es-poo)
- [Ventajas de usar POO](https://github.com/JBV-CODES/Pro-PHP-6/blob/master/Parte1/1.md#ventajas-de-usar-poo)
- [Ejemplo del mundo real](https://github.com/JBV-CODES/Pro-PHP-6/blob/master/Parte1/1.md#ejemplo-del-mundo-real)
- [Conceptos POO](https://github.com/JBV-CODES/Pro-PHP-6/blob/master/Parte1/1.md#conceptos-poo)
- [Clases](https://github.com/JBV-CODES/Pro-PHP-6/blob/master/Parte1/1.md#clases)
- [Objetos](https://github.com/JBV-CODES/Pro-PHP-6/blob/master/Parte1/1.md#objetos)
- [Crear una clase](https://github.com/JBV-CODES/Pro-PHP-6/blob/master/Parte1/1.md#crear-una-clase)
- [Añadir un método](https://github.com/JBV-CODES/Pro-PHP-6/blob/master/Parte1/1.md#añadir-un-método)
- [Añadir una propiedad](https://github.com/JBV-CODES/Pro-PHP-6/blob/master/Parte1/1.md#añadir-una-propiedad)
- [Proteger acceso a variables miembro](https://github.com/JBV-CODES/Pro-PHP-6/blob/master/Parte1/1.md#proteger-acceso-a-variables-miembro)
- [Inicializar objetos](https://github.com/JBV-CODES/Pro-PHP-6/blob/master/Parte1/1.md#inicializar-objetos)
- [Destruir objetos](https://github.com/JBV-CODES/Pro-PHP-6/blob/master/Parte1/1.md#destruir-objetos)
- Herencia
- Sobreescrbir métodos
- Preservar la funcionalidad del método principal
- Como funciona la herencia
- Interfaces : funcionamiento
- Encapsulado
- Cambios POO en PHP 6
- Resumen

####¿Qué es POO?

La **P**rogramación **O**rientada a **O**bjetos es un código de procedimientos para los programadores. Dominando las técnicas de POO mejoran las aplicaciones.

Es una forma de pensar en objetos para construir una aplicación informática. Los objetos permiten modelar código para construir programas. La aplicación es un conjunto de datos que se procesan dentro de las reglas de la POO. Este conjunto de objetos colaboran conjuntamente de forma independiente en la construcción de una aplicación.

Los conceptos de clases y objetos, como se aplican al desarrollo SW de POO. USa conceptos globales y grandes ventajas sobre la Programación de procedimientos. en PHP se implenta POO desde **PHP 5**

####Ventajas de usar POO

- Facilidad de implementación de modulos individuales de negocio.
- Identificación de objetos reales: identificación de personas, cosas y sus relaciones.
- Reutilización de código.
- La clase persona es fácil de copiar de un objeto a otro.
- Modularidad de las clases. Si existe un error en el modulo solo hay que ir a un sitio.

####Ejemplo del mundo real

La modularidad es una gran ventaja. El código más reducido ayuda ahorrar tiempo de depuración y comprensión del código.
POO es una forma concisa y clara de escribir código. La estructura contiene funcionalidades para programar.
Dependiendo del tamaño del proyecto es el tamaño del equipo desarrollador. Se comparten los codigos de otros desarrolladores y los nuevos miembros trabajan con muy poca documentación.

Existe un código base del equipo de desarrollo y siempre es mas fácil añadir a nuevos miembros. Se podrian usar objetos complejos sólo conociendo su función, pero sin necesidad de conocer su implementación.

####Conceptos POO

- **Clase** Define propiedades y metodos de un objeto.

- **Objeto** Instancias de una clase que contiene todos los datos necesario para una aplicación.

- **Herencia** Una clase definida como subtipo de una clase mas generica (cuadrado --> rectángulo).

- **Interfaz** Una clase miembro de varias categorías de clases.

- **Encapsulado** Capacidad de proteger el acceso a los datos internos de una clase.

####Clases

Es la tipica idea de conjuntos de cosas con características similares. En programación una clase es una unidad de código (compuesta por variables y funciones) que describe las características y comportamientos de todos los elementos del conjunto. Las propiedades de una clase son las caracterísiticas y tienen nombre y valor. En la clase coche las **propiedades** pueden ser color, marca, matrícula. Los valores pueden ser **color**:(*blanco, gris, negro, verde*), **marca**:(*renault, citroen, seat, audi, nissan*), **matrícula**:(*3244BDM, V3315GP, 1969JHP, M9612ZP*). 

Los comportamientos o acciones de los elementos de la clase son los métodos. Estos métodos aceptan cualquier número de parámetros. Pueden actuar sobre parámetros externos o sobre propiedades. En la clase coche los **métodos** pueden ser: (*arrancar, acelerar, frenar, embragar, cambiar de marcha*).

####Objetos

Es una instancia concreta de un elemento del que se ha indicado sus características de clase previamente. Entonces para construir un objeto concreto se crea una instancia. Pero para crear una instancia de un objeto deberemos tener:

- *Ubicación en memoria*
- *Los datos de la nueva instancia están contenidos en las propiedades de la clases*

Las clases se manipulan en tiempo de diseño. En ese tiemp orealizamos cambios en los métodos o las propiedades. Los objetos se manipulan en tiempo de ejecución una vez asignadas sus propiedades y se invocan sus métodos. 

####Crear una clase

Un ejemplo sencillo class-demo.php
```PHP
<?php
  class Demo {    }
?>
```
Creamos una instancia del objeto Demo:
```PHP
<?php
  require_once('class.Demo.php');
  $objDemo = new Demo();
?>
```

####Añadir un método

La clase Demo no es útil está vacia. Así que creamos un método.
```PHP
<?php
  class Demo {
    function sayHello($name) {
      print "Hello $name!";
    }
  }
?>
```
Un objeto derivado de la clase puede imprimir un saludo a quien lo invoque. Para invocar el objeto usamos el operador **->** 
```PHP
<?php
require_once('class.Demo.php');
$objDemo = new Demo();
$objDemo->sayHello('Steve');
?>
```
> El operador **->** se se usa siempre para acceder a los métodos y propiedades del objeto. **PHP** no usa el operador punto(.)

####Añadir una propiedad

Es tan fácil añadir una propiedad como un método. solo hay que declarar una variable dentro de la clase para que contenga el valor de la propiedad. La variable se declara al inicio de la declaración de clase entre llaves { } si la variable es *$color*, la propiedad se llamará color.

En este caso *$name* es la variable nombre. Dependiendo del valor de la variable *$nombre* saludará a Steve o a Ed.

```PHP
<?php
require_once('class.Demo.php');

$objDemo = new Demo();
$objDemo->sayHello('Steve');

$objAnotherDemo = new Demo();
$objAnotherDemo->sayHello('Ed');

$objDemo->sayHello();
$objAnotherDemo->sayHello();
?>
```

La palabra clave **public** indica que el acceso es público desde fuera de su clase. En caso de solo ser una
variable de solo uso para la clase propia y no accesible desde fuera de la clase se declara **private o protected**

La variable **$this** es para obtener información del objeto tratado. Es la instancia actual del objeto en caso de tener varios objetos en una misma clase. 

> **$obj.->propiedad** solo la variable de instancia del objeto **con $** La propiedad siempre **sin $**

Además se pueden guardar otras variables para operaciones internas de clase. Algunas de estas variables son externas y otras solo internas.

####Proteger acceso a variables miembro

Podemos establecer el valor de la propiedad **name** en cualquier valor. Pero si establecemos la propiedad **name** no se valida o actualiza ningún otro valor.

Así pues nuestras propiedades se pueden establecer como funciones **get[nombre_prop.] y set[nombre_prop.]** como *métodos de acceso*.

**Class.demo.php**
```PHP
<?php
class Demo {
    private $_name;
    
    public function sayHello() {
      print "Hello " . $this->getName() . "!"
    }
    
    public function getName() {
      return $this->$_name;
    }
    public function setName($name) {
      if (!is_string($name) || strlen($name) == 0){
        throw new exception ("Invalid name value!");
        }
      $this->_name = $name;
    }
  }
?>
```

**testdemo.php**
```PHP
<?php
require_once('class.Demo.php');
$objDemo = new Demo();
$objDemo->setName('Steve');
$objDemo->sayHello();
$objDemo->setName(37); //would trigger an error
?>
```
Ha cambiado el acceso a la variable $_name de **public** a **private** con un prefijo subrayado. Este subrayado es un convenio para variables y funciones privadas. Las variables en **private** evita que un código externo modifique el valor de la variable y no son accesibles desde fuera de la clase.
Tendremos que usar los métodos **getName( ) y setName( )** para obtener información de la variable.

Se emitirá una excepción si se sumistra un valor no válido. Se añade **public** para el acceso a las funciones. Aunque no es necesario por usarse por defecto para la visibilidad de los miembros de clase.

Los niveles de visibilidad serán **public, private, protected** 
- *public*: accesible apara todos.
- *private*: solo accesible desde la propia clase. Usado para:
    - Tareas internas.
    - Elementos de control de conexión de Base de datos o de configuración.
- *protected*: solo accesible desde la propia clase y de las heredadas. Veremos el uso más adelante.

Para no usar la validación de datos en una propiedad deberemos implementar las funciones **get** y **set** para añadir la funcionalidad de validación.

> Usar siempre métodos de acceso a propiedades. Así, los cambios son más fáciles de implementar.

####Inicializar objetos

En muchas **clases** al crearlas será necesario hacer una config. especial. 
- Cuando se cree la instancia por primera vez.
- Obtener info. de de una base de datos.
- inicializar valores de una propiedad.
El contructor se implementa en PHP con la función **_construct()**
Vemos el ejemplo con la *clase Demo*
```PHP
<?php
class Demo {
    private $name;
    public function __construct($name){
    $this->name = $name;
    }
    public function sayHello() {
      print "Hello $this->name!";
    }
  }  
?>
```
La **función _construct** se invoca automáticamente cuando creamos la instancia de un nuevo obj. de la clase Demo.
Hay que actualizar **testdemo.php** para pasar el nombre del constructor en vez del **método set**.

> En **PHP 4** los constructores son funciones con el mismo nombre de la clase
> En **PHP 5** el esquema es de constructor unificado. PHP busca la **función __construct**, si no encuentra ninguna buscará 
> la **función pública Demo()**

No tiene porque crearse el constructor si no hace falta un código de inicalización especial.

####Destruir objetos

*Se crea una tabla widget(componentes) en* **SQL**:
```SQL
CREATE TABLE "widget"(
"widgetid" SERIAL PRIMARY KEY NOT NULL,
"name" varchar(255) NOT NULL,
"description" text
);
```
*Se insertan datos en la tabla* **SQL**:
```SQL
INSERT INTO "widget"("name", "description");
VALUES('Foo','This is a footacular widget!');
```
*Se crea una clase*
**Class.widget.php**
```PHP
<?php
class Widget {

    private $id;
    private $name;
    private $description; private $hDB;
    private $needsUpdating = false;

    public function __construct($widgetID) {
      //The widgetID parameter is the primary key of a
      //record in the database containing the information
      //for this object

      //Create a connection handle and store it in a private member variable
      //This code assumes the DB is called "parts"
      $this->hDB = pg_connect('dbname=parts user=postgres');
      if(! is_resource($this->hDB)) {
        throw new Exception('Unable to connect to the database.');
      }

      $sql = "SELECT \"name\", \"description\" FROM widget WHERE widgetid =
              $widgetID";
      $rs = pg_query($this->hDB, $sql);
      if(! is_resource($rs)) {
        throw new Exception("An error occurred selecting from the database.");
      }

      if(! pg_num_rows($rs)) {
        throw new Exception('The specified widget does not exist!');
      }
      $data = pg_fetch_array($rs);
      $this->id = $widgetID;
      $this->name = $data['name'];
      $this->description = $data['description'];

    }

    public function getName() {
      return $this->name;
    }

    public function getDescription() {
      return $this->description;
    }

    public function setName($name) {
      $this->name = $name;
      $this->needsUpdating = true;
}
    public function setDescription($description) {
      $this->description = $description;
      $this->needsUpdating = true;
    }

   public function __destruct() {
     if($this->needsUpdating) {
    
       $sql = 'UPDATE "widget" SET ';
       $sql .= "\"name\" = '" . pg_escape_string($this->name) . "', ";
       $sql .= "\"description\" = '" . 
       pg_escape_string($this->description) . "' ";
       $sql .= "WHERE widgetID = " . $this->id;

       $rs = pg_query($this->hDB, $sql);
     }
     
     //We're done with the database. Close the connection handle.
     pg_close($this->hDB);
  }
}
?>
```



**Herencia**

**Sobreescrbir métodos**

**Preservar la funcionalidad del método principal**

**Como funciona la herencia**

**Interfaces : funcionamiento**

**Encapsulado**

**Cambios POO en PHP 6**

**Resumen**
